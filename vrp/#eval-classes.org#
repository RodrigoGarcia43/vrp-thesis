#+TITLE: Neighborhood Classes
#+AUTHOR: Rodrigo Garía Gómez
#+EMAIL: rodrigo.garcia21111@gmail.com

* Description
In this file we'll have all the classes invloved in the automatic and effective evaluation of vrp problem solutions. The src code blocks will be tangled to ../src/eval-classes.lisp

* Add the package to the tangled file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/eval-classes.lisp 
    (in-package :vrp)
  #+END_SRC


* Eval-Graph
** Description
The class that represents an evaluation graph. It contains all the information needed for the solution evaluations. The inputs are the clients and routes. The output is the output node. Class to io and slot to output are hash tables used to store the correspondence between =io-nodes= and problem description classes. The node-list is a list of the nodes sorted in the order they where placed. The solution represents the initial solution.
** Code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/eval-classes.lisp 
	(def-vrp-class eval-graph ()
	  ((inputs :initarg :inputs
		   :initform nil)
	   (output :initarg :output
		   :initform nil)
	   (class-to-io :initarg :class-to-io
			:initform (make-hash-table))
	   (slot-to-output :initarg :slot-to-output
			   :initform (make-hash-table))
	   (node-list :initarg :node-list
		      :initform ())
	   (solution :initarg :solution)
	   (client-buffer :initarg :client-buffer
			  :initform ())
	   (vehicle-buffer :initarg :client-buffer
			  :initform ())
	   )
	  :documentation "A class that represents an evaluation graph."
	  :constructor (new-eval-graph (solution))
	  :print-object-string ("<EVAL-GRAPH: ~%output: ~a ~%node-list: ~%~{~a~%~} ~%solution: ~a>" output node-list solution)
	  :slots-for-obj= (inputs outputs class-to-io slot-to-output node-list solution client-buffer vehicle-buffer)
	  :slots-for-clone (inputs outputs class-to-io slot-to-output node-list solution client-buffer vehicle-buffer))


   #+END_SRC



* High level nodes
** documentation
Here will implement the high nodes hierarchy. First we code the node generic class which contains
inputs and outputs. Then we create nodes related to the instance of classes like /clients/ or
/routes/ which play the role of inputs and outputs. Finally we implement the rest of the nodes
related with moments, which the tape are made of.

THE INPUTS/OUTPUTS FEATURES ARE UNDONE CAUSE THEY HAVE TO BE DIVIDED IN THE DIFFERENT TYPE OF
INPUTS AND OUTPUTS RESPECTIVELY

** Root node
*** documentation
Every node will inherits from this class
*** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class node () ()
    :documentation "Ancestor node for eval-graph")
#+END_SRC
*** test (no test)
** IO nodes
*** documentation
Now let's define the nodes that are built from the classes instances, like /client/ or /route/.
These nodes play the role of inputs and outputs of the actual graph nodes.
*** Root node
**** documentation
Ancestor for IO nodes
**** code 
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class io-node (node) ()
    :documentation "ancestor for IO nodes in eval-graph")
#+END_SRC
**** test (no test)
*** Input
**** documetation
The input abstract node
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
    (def-vrp-class input-node (io-node) 
      ((content))
      :documentation "input node node eval-graph")
#+END_SRC
**** test (no test)
*** Distance Input
**** documetation
An input to a node that calculates distances. Contains the references
of the node that increment distance from it to the next client and 
of the node that increment distance from previous client to it.  
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class input-distance-node (input-node) 
    ((first-distance :initform nil)
     (second-distance :initform nil))
    :documentation "distance node in eval-graph"
    :constructor (new-input-distance-node)
    :print-object-string ("<Distance node, first-distance: ~a, second-distance: ~a>" first-distance second-distance)
    :slots-for-obj= (content first-distance second-distance)
    :slots-for-clone (content first-distance second-distance))
#+END_SRC
**** test (no test)
*** Demand Input
**** documentation
An input which contains a client with demand
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class input-demand-node (input-node) 
    ((demand :initform nil))
    :documentation "client with demand node in eval-graph"
    :constructor (new-demand-node)
    :print-object-string ("<Client node, demand: ~a>" demand)
    :slots-for-obj= (demand)
    :slots-for-clone (demand))
#+END_SRC
*** Demand and Distance Input
**** documentation
An input which contains a client with demand and for a problem with
distance
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (defnode input-distance-demand-node (input-distance-node
					    input-demand-node) 
    ()
    :documentation "client with demand node for a problem with distance in eval-graph"
    :constructor (new-input-distance-demand-node)
    :print-object-string ("<Cliient with distance node, first-distance: ~a, second-distance: ~a, demand: ~a>" first-distance second-distance demand)
    :slots-for-obj= (content first-distance second-distance demand)
    :slots-for-clone (content first-distance second-distance demand))
#+END_SRC
*** Output
**** documentation
The output node
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class output-node (io-node) 
    ((output-value))
    :documentation "output node in eval-graph"
    :constructor (new-output-node)   
    :print-object-string ("<Output node, value: ~a>" output-value)
    :slots-for-obj= (output-value)
    :slots-for-clone (output-value))
#+END_SRC
**** test (no test)
*** Accumulator
**** documentation
A class to which accumulates partial results. It can be
output and input at the same time
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class accumulator-node (input-node output-node) 
    ((output-copy)
     (updater))
    :documentation "accumulator node for partial results in eval-graph"
    :constructor (new-accumulator-node)
    :print-object-string ("Accumulator node, content: ~a, output-value: ~a>" content output-value)
    :slots-for-obj= (content output-value)
    :slots-for-clone (content output-value))
#+END_SRC
*** Initial value Accumulator
**** documentation
An accumulator that is initialized with a value that will be modified later
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (defnode initial-value-accumulator-node (accumulator-node) 
    ((initial-value))
    :documentation "accumulator node for partial results in eval-graph"
    :constructor (new-initial-value-accumulator-node)
    :print-object-string ("Initial value accumulator node, initial value: ~a, content: ~a, output-value: ~a>" initial-value content output-value)
    :slots-for-obj= (initial-value content output-value)
    :slots-for-clone (initial-value content output-value))
#+END_SRC
*** Vehicle Input
**** documentation
This is an input for vehicles with capacity. This is usefull
for problems that include heterogeneous fleet
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class input-vehicle-node (input-node) 
    ((dependent-accumulator)) ;; An initial-value accumulator
    :documentation "vehicle node in eval-graph"
    :constructor (new-input-vehicle-node)
    :print-object-string ("Vehicle node, content: ~a, accumulator: ~a>" content accumulator)
    :slots-for-obj= (content accumulator)
    :slots-for-clone (content accumulator)) 
#+END_SRC
*** Depot Input
**** documentation
To represent a simple depot in the tape
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/eval-classes.lisp
  (def-vrp-class input-depot-node (input-distance-demand-node)
    ()
    :documentation "vehicle node in eval-graph"
    :constructor (new-input-depot-node)
    :print-object-string ("Depot node, content: ~a, demand: ~a>" content demand)
    :slots-for-obj= (content demand first-distance second-distance)
    :slots-for-clone (content demand first-distance second-distance))
#+END_SRC

#+RESULTS:
: INPUT:
: NXT INPUT
: OUTPUT:
: PREV OUTPUT
** Exploring methods
*** documentation
Now let's implement the methods that perform the exploration
of the neighbourhood (i.e extract, insert, etc)
*** Remove methods
**** documentation
Methods that performs the extraction of the clients
**** Generic
***** documentation
Generic remove method
***** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defgeneric remove-tape-node (t-node)
    (:method-combination append))
#+END_SRC
**** Primary
***** documentation
Primary remove client method
***** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod remove-tape-node append ((t-node input-tape-node))
    ())
#+END_SRC
**** Specializations
***** documentation
Let's define the specialization methods to remove clients
***** Remove Distance Client Node
****** documentation
Removes clients and calculates delta distance
****** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod remove-tape-node append ((t-node input-distance-tape-node))
 
  (if (not (typep t-node 'input-depot-tape-node)) 
   (progn
      (undo-low-level-node (first-distance-calculator t-node))
      (undo-low-level-node (second-distance-distance-calculator t-node))
      
      (let ((new-inc (increment-distance-tape-node
                                   nil
                                   nil
                                   (output-action (first-distance-calculator t-node))
                                   (from-client (first-distance-calculator t-node))
                                   (to-client (second-distance-calculator t-node))
                                   (distance-matrix (first-distance-calculator t-node)))))
           (progn
               (setf (second-distance-calculator (from-client new-inc))
                     new-inc)
               (setf (first-distance-calculator (to-client new-inc))
                     new-inc)
               `((,#'evaluate-low-level-node ,new-inc)))))))
#+END_SRC
***** Remove Capacity Client Node
****** documentation
Removes clients and calculates delta capacity
****** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod remove-tape-node append ((t-node input-demand-tape-node))
   (if (not (typep t-node 'input-depot-tape-node))
     (progn
      (undo-low-level-node (demand-calculator t-node))
      `((,#'undo-low-level-node ,(updater (output-action (demand-calculator t-node))))))))
#+END_SRC
***** Remove depot node
****** documentation
To remove depots
****** code
#+BEGIN_SRC lisp +n -r :results none :exportts code :tangle src/vrp-tape-node.lisp
(defmethod remove-tape-node append ((t-node input-depot-tape-node))
      (if (second-distance-calculator t-node)
        `((,#'undo-low-level-node ,(increment-distance-tape-node
                                     (previous-node (second-distance-calculator t-node))
                                     (next-node (second-distance-calculator t-node))
                                     (output-action (second-distance-calculator t-node))
                                     (from-client (second-distance-calculator t-node))
                                     (to-client (second-distance-calculator t-node))
                                     (distance-matrix (second-distance-calculator t-node)))))
        `((,#'undo-low-level-node ,(increment-distance-tape-node
                                     (previous-node (first-distance-calculator t-node))
                                     (next-node (first-distance-calculator t-node))
                                     (output-action (first-distance-calculator t-node))
                                     (from-client (first-distance-calculator t-node))
                                     (to-client (first-distance-calculator t-node))
                                     (distance-matrix (first-distance-calculator t-node)))))))
#+END_SRC
*** Insert methods
**** documentation
Methods that performs the insertion of the clients
**** Generic
***** documentation
Generic insert method
***** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defgeneric insert-tape-node (t-node i-node)
    (:method-combination append))
#+END_SRC
**** Primary
***** documentation
Primary insert client method
***** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod insert-tape-node append ((t-node input-tape-node) (i-node input-tape-node))
    ())
#+END_SRC
**** Specializations
***** documentation
Let's define the specialization methods to insert clients
***** Insert Distance Client Node
****** documentation
Inserts clients and calculates delta distance
****** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod insert-tape-node append ((t-node input-distance-tape-node) 
                                      (i-node input-distance-tape-node))
   (if (not (typep i-node 'input-depot-tape-node))  
     (let* ((target-calc (first-distance-calculator t-node))
            (next-client t-node)
            (new-calc (increment-distance-tape-node nil
                                                    nil
                                                    (output-action target-calc)
                                                    i-node
                                                    next-client
                                                    (distance-matrix target-calc))))
           (progn
               (undo-low-level-node target-calc)
               (setf (to-client target-calc) i-node)
               (setf (first-distance-calculator i-node) target-calc)
               (setf (second-distance-calculator i-node) new-calc)
               (setf (first-distance-calculator t-node) new-calc)
               `((,#'evaluate-low-level-node ,target-calc)
                 (,#'evaluate-low-level-node ,new-calc))))))
#+END_SRC
***** Insert Capacity Client Node
****** documentation
Inserts clients and calculates delta capacity
****** code

;;;; (undo-low-level-node (updater (output-action new-inc))))))
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod insert-tape-node append ((t-node input-demand-tape-node) 
                                      (i-node input-demand-tape-node))
   (let* ((new-inc (decrement-capacity-tape-node nil 
                                                 nil
                                                 (output-action (demand-calculator t-node))
                                                 i-node)))
       (progn
          (setf (demand-calculator i-node) new-inc)
          `((,#'evaluate-low-level-node ,new-inc)))))
          


#+END_SRC
***** Insert depot
****** documentation
To insert a depot of the route. If the =second-calculator= slot
of the =i-node= (node to insert) is =nil=, then it is inserted
as a destination depot else it is inserted as an origin depot 
****** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod insert-tape-node append ((t-node input-distance-tape-node) 
                                      (i-node input-depot-tape-node))
   (let* ((is-origin (if (second-distance-calculator i-node) t nil))
          (calc (if is-origin 
                    (first-distance-calculator t-node)
                    (second-distance-calculator t-node))))
       (progn
          (if is-origin
              (progn 
                  (setf (second-distance-calculator i-node) calc)
                  (setf (from-client calc) i-node))
              (progn
                  (setf (first-distance-calculator i-node) calc)
                  (setf (to-client calc) i-node)))
          `((,#'evaluate-low-level-node ,calc)))))
#+END_SRC
* Low level nodes
** documentation
Nodes that represents low level operations like increment total-distance, etc.
** Root node
*** documentation
A class to distinguish the low level nodes from the high level ones.
*** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defnode low-level-tape-node (tape-node) 
         (previous-node 
          next-node 
          output-action))
#+END_SRC
*** test (no test)
** Increment distance node
*** documentation
A node to represent the increment distance operation
*** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defnode increment-distance-tape-node (low-level-tape-node) 
    (from-client
     to-client
     distance-matrix))
#+END_SRC
** Decrement capacity node
*** documentation
This node is the one which decrement the
capacity of the vehicle assingned to a route
in the same value that have the demand of the
current client. Actually we increment an action
slot called total-demand, that is equivalent
to decrement the actual capacity of the vehicle.
*** code 
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defnode decrement-capacity-tape-node (low-level-tape-node) (input-with-demand))
#+END_SRC
** Increment accumulator node
*** documentation
This node is the one to increment the value of an accumulator with the
value of another one
*** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defnode increment-accumulator-tape-node (low-level-tape-node)
    (partial-accumulator))
#+END_SRC
** Penalize node
*** documentation
This node is the one that penalizes a magnitude
and stores it in another accumulator
*** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defnode penalize-accumulator-tape-node (low-level-tape-node)
    (partial-accumulator
     factor))
#+END_SRC
** Evaluation methods
*** documentation
Actions that perform every low level node
*** Generic
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defgeneric evaluate-low-level-node (ll-node)
   (:documentation "The generic action to do in the low level tape node"))
#+END_SRC
*** Primary
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod evaluate-low-level-node ((ll-node low-level-tape-node))
   ())
#+END_SRC
*** Specialized
**** documentation
Let's define the specialization methods of the actions
**** Increment distance low level node
***** documentation
Incremets the target distance
***** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod evaluate-low-level-node ((ll-node increment-distance-tape-node))
   (progn
       (incf (output-value (output-action ll-node))
         (aref (distance-matrix ll-node) 
               (id (content (from-client ll-node))) 
               (id (content (to-client ll-node)))))
       (if (updater (output-action ll-node))
           `(,#'undo-low-level-node ,(updater (output-action ll-node)))
            nil)))
#+END_SRC
**** Decrement capacity low level node
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod evaluate-low-level-node ((ll-node decrement-capacity-tape-node))
   (progn
         (decf (output-value (output-action ll-node)) 
               (demand (content (input-with-demand ll-node))))
         (if (updater (output-action ll-node))
          `(,#'undo-low-level-node ,(updater (output-action ll-node))))))
#+END_SRC
**** Update accumulator with increment
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod evaluate-low-level-node ((ll-node increment-accumulator-tape-node))
   (progn
       (setf (output-copy (partial-accumulator ll-node))
             (output-value (partial-accumulator ll-node)))
       (incf (output-value (output-action ll-node)) 
             (output-value (partial-accumulator ll-node)))
       nil))
#+END_SRC
**** Penalize accumulator
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod evaluate-low-level-node :after ((ll-node penalize-accumulator-tape-node))
   (let ((penal-amount (* (max (- (output-value (partial-accumulator ll-node))) 0) (factor ll-node))))
        (progn 
             (setf (output-copy (partial-accumulator ll-node))
                   (min 0 (output-value (partial-accumulator ll-node))))
             (incf (output-value (output-action ll-node))
                    penal-amount)
             nil)))
#+END_SRC
** Undo methods
*** documentation
Methods to revert the effect of the evaluation
*** Generic
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defgeneric undo-low-level-node (ll-node)
   (:documentation "The generic action to undo the low level tape node evaluation"))
#+END_SRC
*** Primary
**** code
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod undo-low-level-node ((ll-node low-level-tape-node))
   ())
#+END_SRC
*** Specialized
**** documentation
Let's define the specialization methods of the actions
**** Increment distance low level node
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod undo-low-level-node ((ll-node increment-distance-tape-node))
   (progn
       (decf (output-value (output-action ll-node)) 
         (aref (distance-matrix ll-node) 
               (id (content (from-client ll-node))) 
               (id (content (to-client ll-node)))))
       (if (updater (output-action ll-node))
           `((,#'undo-low-level-node ,(updater (output-action ll-node)))))))
#+END_SRC
**** Decrement capacity low level node
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod undo-low-level-node ((ll-node decrement-capacity-tape-node))
   (progn
         (incf (output-value (output-action ll-node)) 
               (demand (content (input-with-demand ll-node))))
         nil))
#+END_SRC
**** Update accumulator with increment
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod undo-low-level-node :after ((ll-node increment-accumulator-tape-node))
    (progn 
        (incf (output-value (output-action ll-node))
              (- (output-value (partial-accumulator ll-node))
                 (output-copy (partial-accumulator ll-node))))
        (setf (output-copy (partial-accumulator ll-node)) 
              (output-value (partial-accumulator ll-node)))
        (if (updater (output-action ll-node))
            (undo-low-level-node (updater (output-action ll-node))))))
#+END_SRC
**** Penalize accumulator
#+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/vrp-tape-node.lisp
(defmethod undo-low-level-node :after ((ll-node penalize-accumulator-tape-node))
    (let ((former-p (* (- (output-copy (partial-accumulator ll-node)))
                       (factor ll-node)))
          (current-p (* (max 0 (- (output-value (partial-accumulator ll-node))))
                        (factor ll-node))))
        (progn
            (decf (output-value (output-action ll-node))
                   former-p)
            (incf (output-value (output-action ll-node))
                   current-p)
            (setf (output-copy (partial-accumulator ll-node)) 
                  (min 0 (output-value (partial-accumulator ll-node))))
            (if (updater (output-action ll-node))
                `((,#'undo-low-level-node ,(updater (output-action ll-node))))))))
#+END_SRC
