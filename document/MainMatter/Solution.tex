\chapter{Propuesta de solución}\label{chapter:Solution}

En este capítulo se describe el sistema implementado.

\section{Formato org}\label{3-org}
El sistema está desarrollado sobre una serie de archivos con formato org (Lotus Organizer File). Org es un modo Emacs para guardar notas, mantener listas TODO, y hacer planificación de proyectos con un rápido y efectivo sistema de texto plano. Es también un sistema de publicación y autoría, que soporta trabajar con código fuente para programación literal e investigación reproducible \cite{TODO}.

Org facilita la organización de los archivos facilitando la separación de los datos en regiones. Los títulos de cada región comienzan con una cierta cantidad de símbolos "$\ast$". Las regiones se ramifican en subregiones de acuerdo a la cantidad de asteriscos.

El texto plano en los archivos contiene información y explicaciones de los elementos implementados. Además, Org-mode proporciona un número de funcionalidades para trabajar con código fuente, incluyendo la edición, evaluación y exportación de bloques código.

La estructura de bloques de código es como sigue:\\
\#+NAME: $<$name$>$\\
\#+BEGIN\_SRC $<$language$>$ $<$switches$>$ $<$header arguments$>$\\
$<$body$>$\\
\#+END\_SRC

Donde $<$name$>$ es una cadena usada para nombrar el bloque de código $<$language$>$ que especifica el lenguaje del bloque de código (lisp en este caso) $<$switches$>$ puede usarse para controlar la exportación del bloque de código, $<$header arguments$>$ puede usarse para controlar muchos aspectos del comportamiento de bloques de código, y el $<$body$>$ contiene el código fuente actual.

El argumento de cabezera $:tangle$ $<archivo>$ permite exportar los bloques de código al archivo seleccionado. en este caso, los códigos se exportan a archivos con formato \textit{.lisp} que son creados en la carpeta \textit{src} ubicada en la raíz del sistema. Los archivos de \textit{src} contienen todas las funciones que deben ser importadas para utilizar el sistema. El proceso de inicialización del sistema se explica en \ref{chapter:Tutorial}.

La implementación sistema está dividida en cuatro secciones principales.

\begin{itemize}
	\item \textit{Core}: Contiene funciones para inicializar el sistema, datos de instancias conocidas de VRP y criterios clásicos, implementaciones de algoritmos de búsqueda local y definiciones de clases a partir de las cuales es posible definir un problema de VRP en lenguaje Common Lisp.
	\item \textit{Neigh}: En los archivos de \textit{neigh} se implementa el árbol de vecindad a partir del cual se generan soluciones.
	\item \textit{Eval}: En \textit{eval} se implementa el grafo de evaluación con el que se evalúan soluciones.
	\item \textit{Blueprint}: Esta sección contiene código para generar funciones de exploración a partir de combinaciones de estrategias de exploración y selección.
\end{itemize}

Para resolver computacionalmente un problema, el primer paso es definir una forma para describirlo a partir de código. La sección \textbf{core} es la base del sistema. 


\section{Vrp-Core}\label{3-core}

En \textit{core} se definen funciones útiles para inicializar fácilmente el sistema, datos de instancias conocidas de VRP y criterios clásicos útiles para la investigación, así como la implementaciones de algoritmos de búsqueda local que utilizan funciones del sistema para la exploración de vecindades. Estos elementos serán analizados a profundidad en \ref{chapter:Tutorial}.

Se definen además una serie de clases a partir de las cuales es posible definir problemas de VRP con sus especificaciones y restricciones en lenguaje Common Lisp. Los elementos que forman un problema están definidos en clases. Los elementos que presenta un VRP en sus versiones más simples son:

\begin{enumerate}
	\item Clientes
	\item Vehículos
	\item Depósitos
\end{enumerate}

Siendo las variaciones de VRP sólo limitadas por la imaginación, las características específicas de estas variaciones son también virtualmente infinitas. Por ejemplo, para el Problema de Enrutamiento de Vehículos con Múltiples productos \cite{TODO}, se ha definido también \textit{Producto como una característica}. Cómo ampliar el sistema para definir otras variantes de VRP se discute en \ref{chapter:Tutorial}. También se tienen clases para representar rutas y soluciones.

Para crear una instancia de un problema de VRP deben instanciarse elementos acordes a sus especificidades. Por ejemplo, una instancia de VRP clásico utiliza clientes básicos, mientras que una de CVRP trabaja con clientes con demanda.

Se utiliza la herencia múltiple de Common Lisp para definir las características de cada elemento mediante clases abstractas. Por ejemplo, un vehículo de CVRP (\textbf{cvrp-vehicle}) se define como una clase que hereda de las clases abstractas: \textbf{basic-vehicle} (vehículo básico), \textbf{capacity-vehicle} (vehículo con capacidad) y \textbf{cargo-vehícle} (vehículo que lleva carga).














